// Copyright 2019-2024 The Khronos Group, Inc.
// SPDX-License-Identifier: CC-BY-4.0

ifndef::chapters[:chapters: ../]
ifndef::images[:images: ../images/]

[[deprecated_items_guide]]
= Deprecated Items Guide

This guide provides fallback instructions for deprecated items in Vulkan. It helps developers understand what deprecated features were, what they did, and how to use their modern replacements while maintaining backward compatibility where needed.

== Deprecated Items

The following table lists deprecated items in Vulkan along with their replacements and links to detailed fallback instructions:

[cols="2,3,3,2", options="header"]
|===
|Deprecated Item |What it was/did |Replacement |When Deprecated

|Device Layers
|Device layers were a way to intercept, evaluate, and modify Vulkan functions at the device level.
|Instance layers should be used instead. All layer functionality is now available through instance layers.
|Early in Vulkan's life

|VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
|Used in synchronization to represent the earliest possible pipeline stage.
|Different replacements depending on usage context. See <<top_of_pipe_replacement>> for details.
|With VK_KHR_synchronization2

|VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
|Used in synchronization to represent the latest possible pipeline stage.
|Different replacements depending on usage context. See <<bottom_of_pipe_replacement>> for details.
|With VK_KHR_synchronization2

|VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
|Used to represent the vertex input stage in the pipeline.
|Split into more specific flags: `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR` and `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR`.
|With VK_KHR_synchronization2

|VK_PIPELINE_STAGE_ALL_TRANSFER_BIT
|Used to represent all transfer operations in the pipeline.
|Split into more specific flags: `VK_PIPELINE_STAGE_2_COPY_BIT_KHR`, `VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR`, `VK_PIPELINE_STAGE_2_BLIT_BIT_KHR`, and `VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR`.
|With VK_KHR_synchronization2

|VK_ACCESS_SHADER_READ_BIT
|Used to represent all shader read operations.
|Split into more specific flags: `VK_ACCESS_2_UNIFORM_READ_BIT_KHR`, `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR`, and `VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR`.
|With VK_KHR_synchronization2

|VK_ACCESS_SHADER_WRITE_BIT
|Used to represent shader write operations.
|Renamed to `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR` to better describe the scope of what resources in the shader are described by the access flag.
|With VK_KHR_synchronization2
|===

== How to Use This Guide

1. **Identify Deprecated Items**: Determine if your application uses any deprecated Vulkan features.
2. **Understand the Replacement**: Read about what each deprecated item was and its recommended replacement.
3. **Implement Fallbacks**: Use the detailed sections below to implement proper fallbacks for backward compatibility.
4. **Test Thoroughly**: Ensure your application works correctly with both the deprecated item and its replacement.

== Notes on Deprecation

* Deprecated items may still work in current Vulkan implementations but could be removed in future versions.
* Using replacements for deprecated items often provides better performance or more precise control.
* When targeting newer Vulkan versions, it's best to use the recommended replacements.
* For backward compatibility with older Vulkan implementations, fallback code may be necessary.

== Additional Resources

* link:https://docs.vulkan.org/spec/latest/[Vulkan Specification]: Official documentation for all Vulkan features
* link:https://github.com/KhronosGroup/Vulkan-Samples[Vulkan Samples]: Sample code demonstrating various Vulkan features
* link:checking_for_support.adoc[Checking for Support]: Guide on how to check for feature support at runtime
* link:versions.adoc[Vulkan Versions]: Information about different Vulkan versions and their features

== Detailed Fallback Instructions

[[device_layers_replacement]]
=== Device Layers

Device layers were a way to intercept, evaluate, and modify Vulkan functions at the device level. They were deprecated early in Vulkan's life in favor of instance layers.

==== What They Were

Device layers were similar to instance layers but were associated with a specific VkDevice. They allowed for device-specific validation and debugging.

==== Replacement

All layer functionality is now available through instance layers. Instance layers can intercept both instance-level and device-level Vulkan functions.

==== Code Example

[source,cpp]
----
// DEPRECATED: Using device layers
const char* deviceLayerNames[] = { "VK_LAYER_LUNARG_standard_validation" };
VkDeviceCreateInfo createInfo = {};
createInfo.enabledLayerCount = 1;
createInfo.ppEnabledLayerNames = deviceLayerNames;
vkCreateDevice(physicalDevice, &createInfo, nullptr, &device);

// RECOMMENDED: Using instance layers only
const char* instanceLayerNames[] = { "VK_LAYER_KHRONOS_validation" };
VkInstanceCreateInfo instanceCreateInfo = {};
instanceCreateInfo.enabledLayerCount = 1;
instanceCreateInfo.ppEnabledLayerNames = instanceLayerNames;
vkCreateInstance(&instanceCreateInfo, nullptr, &instance);

// When creating the device, don't specify any layers
VkDeviceCreateInfo createInfo = {};
createInfo.enabledLayerCount = 0;
createInfo.ppEnabledLayerNames = nullptr;
vkCreateDevice(physicalDevice, &createInfo, nullptr, &device);
----

==== Fallback Strategy

Since device layers were deprecated very early, there's no need for a fallback strategy. All Vulkan implementations should support instance layers instead of device layers.

[[top_of_pipe_replacement]]
=== VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT

`VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` was used in synchronization to represent the earliest possible pipeline stage. It was deprecated with the introduction of VK_KHR_synchronization2.

==== What It Was

This flag represented a "pseudo-stage" at the beginning of the pipeline, before any actual work begins. It was often used in synchronization primitives to indicate that a dependency should be satisfied before any actual work begins.

==== Replacement

The replacement depends on the context in which `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` is used:

1. When used in the first synchronization scope (srcStageMask):
   * Replace with `VK_PIPELINE_STAGE_2_NONE_KHR` and `VK_ACCESS_2_NONE_KHR`

2. When used in the second synchronization scope (dstStageMask):
   * Replace with `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR` and `VK_ACCESS_2_NONE_KHR`

==== Code Example

[source,cpp]
----
// DEPRECATED: Using VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT in srcStageMask
VkMemoryBarrier memoryBarrier = {
    .srcAccessMask = 0,
    .dstAccessMask = VK_ACCESS_SHADER_READ_BIT
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,  // srcStageMask
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,  // dstStageMask
    0,
    1, &memoryBarrier,
    0, nullptr,
    0, nullptr
);

// RECOMMENDED: Using VK_PIPELINE_STAGE_2_NONE_KHR in srcStageMask
VkMemoryBarrier2KHR memoryBarrier2 = {
    .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR,
    .pNext = nullptr,
    .srcStageMask = VK_PIPELINE_STAGE_2_NONE_KHR,
    .srcAccessMask = VK_ACCESS_2_NONE_KHR,
    .dstStageMask = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR,
    .dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR
};

VkDependencyInfoKHR dependencyInfo = {
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
    .pNext = nullptr,
    .dependencyFlags = 0,
    .memoryBarrierCount = 1,
    .pMemoryBarriers = &memoryBarrier2,
    .bufferMemoryBarrierCount = 0,
    .pBufferMemoryBarriers = nullptr,
    .imageMemoryBarrierCount = 0,
    .pImageMemoryBarriers = nullptr
};

vkCmdPipelineBarrier2KHR(commandBuffer, &dependencyInfo);
----

==== Fallback Strategy

To support both deprecated and new APIs, you can check for the availability of the VK_KHR_synchronization2 extension:

[source,cpp]
----
bool hasSync2 = false;
// Check if VK_KHR_synchronization2 is available
uint32_t extensionCount = 0;
vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, nullptr);
std::vector<VkExtensionProperties> extensions(extensionCount);
vkEnumerateDeviceExtensionProperties(physicalDevice, nullptr, &extensionCount, extensions.data());

for (const auto& extension : extensions) {
    if (strcmp(extension.extensionName, VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME) == 0) {
        hasSync2 = true;
        break;
    }
}

// Function to create a barrier based on available extensions
void CreateBarrier(VkCommandBuffer commandBuffer, bool isSourceTopOfPipe) {
    if (hasSync2) {
        // Use synchronization2 API
        VkMemoryBarrier2KHR memoryBarrier2 = {
            .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR,
            .pNext = nullptr,
            .srcStageMask = isSourceTopOfPipe ? VK_PIPELINE_STAGE_2_NONE_KHR : VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR,
            .srcAccessMask = VK_ACCESS_2_NONE_KHR,
            .dstStageMask = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR,
            .dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR
        };

        VkDependencyInfoKHR dependencyInfo = {
            .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
            .pNext = nullptr,
            .dependencyFlags = 0,
            .memoryBarrierCount = 1,
            .pMemoryBarriers = &memoryBarrier2,
            .bufferMemoryBarrierCount = 0,
            .pBufferMemoryBarriers = nullptr,
            .imageMemoryBarrierCount = 0,
            .pImageMemoryBarriers = nullptr
        };

        vkCmdPipelineBarrier2KHR(commandBuffer, &dependencyInfo);
    } else {
        // Use original API
        VkMemoryBarrier memoryBarrier = {
            .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER,
            .pNext = nullptr,
            .srcAccessMask = 0,
            .dstAccessMask = VK_ACCESS_SHADER_READ_BIT
        };

        vkCmdPipelineBarrier(
            commandBuffer,
            VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,  // srcStageMask
            VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,  // dstStageMask
            0,
            1, &memoryBarrier,
            0, nullptr,
            0, nullptr
        );
    }
}
----

[[bottom_of_pipe_replacement]]
=== VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT

`VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` was used in synchronization to represent the latest possible pipeline stage. It was deprecated with the introduction of VK_KHR_synchronization2.

==== What It Was

This flag represented a "pseudo-stage" at the end of the pipeline, after all actual work is completed. It was often used in synchronization primitives to indicate that a dependency should be satisfied after all work is completed.

==== Replacement

The replacement depends on the context in which `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` is used:

1. When used in the first synchronization scope (srcStageMask):
   * Replace with `VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR` and `VK_ACCESS_2_NONE_KHR`

2. When used in the second synchronization scope (dstStageMask):
   * Replace with `VK_PIPELINE_STAGE_2_NONE_KHR` and `VK_ACCESS_2_NONE_KHR`

==== Code Example

[source,cpp]
----
// DEPRECATED: Using VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT in srcStageMask
VkMemoryBarrier memoryBarrier = {
    .srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT,
    .dstAccessMask = 0
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,  // srcStageMask
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,  // dstStageMask
    0,
    1, &memoryBarrier,
    0, nullptr,
    0, nullptr
);

// RECOMMENDED: Using VK_PIPELINE_STAGE_2_NONE_KHR in dstStageMask
VkMemoryBarrier2KHR memoryBarrier2 = {
    .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR,
    .pNext = nullptr,
    .srcStageMask = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR,
    .srcAccessMask = VK_ACCESS_2_SHADER_WRITE_BIT_KHR,
    .dstStageMask = VK_PIPELINE_STAGE_2_NONE_KHR,
    .dstAccessMask = VK_ACCESS_2_NONE_KHR
};

VkDependencyInfoKHR dependencyInfo = {
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
    .pNext = nullptr,
    .dependencyFlags = 0,
    .memoryBarrierCount = 1,
    .pMemoryBarriers = &memoryBarrier2,
    .bufferMemoryBarrierCount = 0,
    .pBufferMemoryBarriers = nullptr,
    .imageMemoryBarrierCount = 0,
    .pImageMemoryBarriers = nullptr
};

vkCmdPipelineBarrier2KHR(commandBuffer, &dependencyInfo);
----

==== Fallback Strategy

The fallback strategy is similar to the one for `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT`. Check for the availability of the VK_KHR_synchronization2 extension and use the appropriate API.

[[vertex_input_replacement]]
=== VK_PIPELINE_STAGE_VERTEX_INPUT_BIT

`VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` was used to represent the vertex input stage in the pipeline. With VK_KHR_synchronization2, it was split into more specific flags.

==== What It Was

This flag represented the stage of the pipeline where vertex and index data is consumed. It was used in synchronization primitives to indicate operations related to vertex input.

==== Replacement

Split into more specific flags:
* `VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR`: Represents the stage where index data is consumed
* `VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR`: Represents the stage where vertex attribute data is consumed

==== Code Example

[source,cpp]
----
// DEPRECATED: Using VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
VkBufferMemoryBarrier bufferBarrier = {
    .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
    .dstAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    .buffer = vertexBuffer,
    // ... other fields
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_TRANSFER_BIT,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    0,
    0, nullptr,
    1, &bufferBarrier,
    0, nullptr
);

// RECOMMENDED: Using specific vertex input stage flags
VkBufferMemoryBarrier2KHR bufferBarrier2 = {
    .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR,
    .pNext = nullptr,
    .srcStageMask = VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR,
    .srcAccessMask = VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR,
    .dstStageMask = VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR,
    .dstAccessMask = VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .buffer = vertexBuffer,
    .offset = 0,
    .size = VK_WHOLE_SIZE
};

VkDependencyInfoKHR dependencyInfo = {
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
    .pNext = nullptr,
    .dependencyFlags = 0,
    .memoryBarrierCount = 0,
    .pMemoryBarriers = nullptr,
    .bufferMemoryBarrierCount = 1,
    .pBufferMemoryBarriers = &bufferBarrier2,
    .imageMemoryBarrierCount = 0,
    .pImageMemoryBarriers = nullptr
};

vkCmdPipelineBarrier2KHR(commandBuffer, &dependencyInfo);
----

==== Fallback Strategy

Check for the availability of the VK_KHR_synchronization2 extension and use the appropriate API. When using the new API, choose the most specific flag that applies to your use case.

[[all_transfer_replacement]]
=== VK_PIPELINE_STAGE_ALL_TRANSFER_BIT

`VK_PIPELINE_STAGE_ALL_TRANSFER_BIT` was used to represent all transfer operations in the pipeline. With VK_KHR_synchronization2, it was split into more specific flags.

==== What It Was

This flag represented all transfer operations, including copy, resolve, blit, and clear operations. It was used in synchronization primitives to indicate operations related to data transfer.

==== Replacement

Split into more specific flags:
* `VK_PIPELINE_STAGE_2_COPY_BIT_KHR`: Represents copy operations
* `VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR`: Represents resolve operations
* `VK_PIPELINE_STAGE_2_BLIT_BIT_KHR`: Represents blit operations
* `VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR`: Represents clear operations

==== Code Example

[source,cpp]
----
// DEPRECATED: Using VK_PIPELINE_STAGE_ALL_TRANSFER_BIT
VkImageMemoryBarrier imageBarrier = {
    .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
    .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
    .oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    .newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    .image = image,
    // ... other fields
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_ALL_TRANSFER_BIT,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    0,
    0, nullptr,
    0, nullptr,
    1, &imageBarrier
);

// RECOMMENDED: Using specific transfer stage flags
VkImageMemoryBarrier2KHR imageBarrier2 = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR,
    .pNext = nullptr,
    .srcStageMask = VK_PIPELINE_STAGE_2_COPY_BIT_KHR,  // Assuming a copy operation
    .srcAccessMask = VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR,
    .dstStageMask = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR,
    .dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR,
    .oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    .newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = image,
    .subresourceRange = {
        .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
        .baseMipLevel = 0,
        .levelCount = 1,
        .baseArrayLayer = 0,
        .layerCount = 1
    }
};

VkDependencyInfoKHR dependencyInfo = {
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
    .pNext = nullptr,
    .dependencyFlags = 0,
    .memoryBarrierCount = 0,
    .pMemoryBarriers = nullptr,
    .bufferMemoryBarrierCount = 0,
    .pBufferMemoryBarriers = nullptr,
    .imageMemoryBarrierCount = 1,
    .pImageMemoryBarriers = &imageBarrier2
};

vkCmdPipelineBarrier2KHR(commandBuffer, &dependencyInfo);
----

==== Fallback Strategy

Check for the availability of the VK_KHR_synchronization2 extension and use the appropriate API. When using the new API, choose the most specific flag that applies to your use case.

[[shader_read_replacement]]
=== VK_ACCESS_SHADER_READ_BIT

`VK_ACCESS_SHADER_READ_BIT` was used to represent all shader read operations. With VK_KHR_synchronization2, it was split into more specific flags.

==== What It Was

This flag represented all read operations performed by shaders, including reading from uniform buffers, storage buffers, and sampled images. It was used in synchronization primitives to indicate shader read operations.

==== Replacement

Split into more specific flags:
* `VK_ACCESS_2_UNIFORM_READ_BIT_KHR`: Represents reads from uniform buffers
* `VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR`: Represents reads from sampled images
* `VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR`: Represents reads from storage buffers and images

==== Code Example

[source,cpp]
----
// DEPRECATED: Using VK_ACCESS_SHADER_READ_BIT
VkImageMemoryBarrier imageBarrier = {
    .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
    .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
    .oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    .newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    .image = image,
    // ... other fields
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_TRANSFER_BIT,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    0,
    0, nullptr,
    0, nullptr,
    1, &imageBarrier
);

// RECOMMENDED: Using specific shader read access flags
VkImageMemoryBarrier2KHR imageBarrier2 = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR,
    .pNext = nullptr,
    .srcStageMask = VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR,
    .srcAccessMask = VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR,
    .dstStageMask = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR,
    .dstAccessMask = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR,  // Assuming a sampled image
    .oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    .newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = image,
    .subresourceRange = {
        .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
        .baseMipLevel = 0,
        .levelCount = 1,
        .baseArrayLayer = 0,
        .layerCount = 1
    }
};

VkDependencyInfoKHR dependencyInfo = {
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
    .pNext = nullptr,
    .dependencyFlags = 0,
    .memoryBarrierCount = 0,
    .pMemoryBarriers = nullptr,
    .bufferMemoryBarrierCount = 0,
    .pBufferMemoryBarriers = nullptr,
    .imageMemoryBarrierCount = 1,
    .pImageMemoryBarriers = &imageBarrier2
};

vkCmdPipelineBarrier2KHR(commandBuffer, &dependencyInfo);
----

==== Fallback Strategy

Check for the availability of the VK_KHR_synchronization2 extension and use the appropriate API. When using the new API, choose the most specific flag that applies to your use case.

[[shader_write_replacement]]
=== VK_ACCESS_SHADER_WRITE_BIT

`VK_ACCESS_SHADER_WRITE_BIT` was used to represent shader write operations. With VK_KHR_synchronization2, it was renamed to better describe its scope.

==== What It Was

This flag represented write operations performed by shaders to storage buffers and images. It was used in synchronization primitives to indicate shader write operations.

==== Replacement

Renamed to `VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR` to better describe the scope of what resources in the shader are described by the access flag.

==== Code Example

[source,cpp]
----
// DEPRECATED: Using VK_ACCESS_SHADER_WRITE_BIT
VkBufferMemoryBarrier bufferBarrier = {
    .srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT,
    .dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT,
    .buffer = storageBuffer,
    // ... other fields
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    VK_PIPELINE_STAGE_TRANSFER_BIT,
    0,
    0, nullptr,
    1, &bufferBarrier,
    0, nullptr
);

// RECOMMENDED: Using VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR
VkBufferMemoryBarrier2KHR bufferBarrier2 = {
    .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR,
    .pNext = nullptr,
    .srcStageMask = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR,
    .srcAccessMask = VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR,
    .dstStageMask = VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR,
    .dstAccessMask = VK_ACCESS_2_TRANSFER_READ_BIT_KHR,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .buffer = storageBuffer,
    .offset = 0,
    .size = VK_WHOLE_SIZE
};

VkDependencyInfoKHR dependencyInfo = {
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR,
    .pNext = nullptr,
    .dependencyFlags = 0,
    .memoryBarrierCount = 0,
    .pMemoryBarriers = nullptr,
    .bufferMemoryBarrierCount = 1,
    .pBufferMemoryBarriers = &bufferBarrier2,
    .imageMemoryBarrierCount = 0,
    .pImageMemoryBarriers = nullptr
};

vkCmdPipelineBarrier2KHR(commandBuffer, &dependencyInfo);
----

==== Fallback Strategy

Check for the availability of the VK_KHR_synchronization2 extension and use the appropriate API.
